# Fortuna in Chisel

## Introduction

The **Fortuna in Chisel** is a hardware design using **[Chisel](https://www.chisel-lang.org/)** that implements a **pseudo-random number generator (PRNG)** based on the  **[Fortuna algorithm](https://www.researchgate.net/publication/215858122_Fortuna_Cryptographically_Secure_Pseudo-Random_Number_Generation_In_Software_And_Hardware).** It translates the well-established Fortuna algorithm, originally specified for software, into a modular, synthesizable hardware architecture suitable for FPGA-based systems.

![1762873081647](image/README/1762873081647.png)

## Core Architecture

## 1. Seed Generator

The **Seed Generator** module is responsible for producing random seeds that serve as cryptographic keys for the Generator core. In this design, we utilize a **SHA-256** hashing engine to transform collected entropy into a  **256-bit hash value**, which is then used as the seed for Fortuna’s generator core.

### 2. Pools

The **Pool** module is responsible for **storing 256-bit hash seeds** generated by the Seed Generator. These stored seeds act as the cryptographic keys used by the Generator core when producing random numbers. By separating the seed storage from the Seed Generator itself, the design ensures controlled reseeding and secure handling of previous seeds.

### 3. Generator Core

The **Generator core** is the heart of Fortuna, it will produce the random number by utilizing seed as the encryption key and counter 128-bit as the plaintext. It will generate 128-bit random number. In this design, **AES-256** is used as the primary generator core, with **ChaCha** and **Salsa20** provided as alternative stream-cipher implementations.

## Project Layout

- **Sources**: `Agile-HW-Design-RNG/src/main/scala/`
  - `AES256.scala`  - AES‑256 (ECB core) Chisel module.
  - `SHA256.scala` - Single‑block SHA‑256 core (iterative 64 rounds).
  - `SHAd256.scala` - Double SHA‑256 core: SHA‑256(SHA‑256(msg)).
  - `ChaCha.scala` - ChaCha‑like 512‑bit keystream block generator.
  - `Salsa20.scala` - Salsa20 512‑bit keystream block generator.
  - `Emit.scala`  - `runMain` emitters for SystemVerilog generation.
  - `Pools.scala` - Simple seeding pools component for RNG reseeding logic.
  - `top_fsm.scala` - Fortuna control state machine skeleton.
- **Tests**: `Agile-HW-Design-RNG/src/test/scala/`
  - `AES256Test.scala` - AES unit test with PKCS#7 padding and known vector.
  - `CoSimulationTest.scala` - Co‑simulation against Java golden models (AES, SHA256, SHAd256).
  - `SHA256Tester.scala` - Single‑block SHA‑256 “abc” known‑answer test.
  - `SHAd256Tester.scala` - Double SHA‑256 “abc” known‑answer test.
  - `PoolsTester.scala` - Pools module sanity test.

## Hardware Modules Descriptions

### SHA256 Module

Module implementation is based on [Secure Hash Standard Document](https://csrc.nist.gov/files/pubs/fips/180-2/final/docs/fips180-2.pdf) published by National
Institute of Standards and Technology (NIST)

- IO (file: `Agile-HW-Design-RNG/src/main/scala/SHA256.scala`)

  - `io.in: UInt(512.W)` - pre‑padded 512‑bit message block.
  - `io.start: Bool` - start pulse; sample `io.in` and begin hashing.
  - `io.done: Bool` - high when digest is valid.
  - `io.out: UInt(256.W)` - hashed message

### SHAd256 Module

- IO (file: `Agile-HW-Design-RNG/src/main/scala/SHAd256.scala`)
  - Same interface as `SHA256` (`in/start/ready/done/out`)

### AES256 Module

Module implementation is based on [Advanced Encryption Standard Document](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf) published by National
Institute of Standards and Technology (NIST)

- IO (file: `Agile-HW-Design-RNG/src/main/scala/AES256.scala`)
  - `io.in_data: UInt(128.W)` - plaintext block.
  - `io.in_key: UInt(256.W)` - cipher key.
  - `io.start: Bool`, `io.ready: Bool`, `io.done: Bool` - handshake.
  - `io.out: UInt(128.W)` - ciphertext block output.

### Pools

- IO (file: `Agile-HW-Design-RNG/src/main/scala/Pools.scala`)
  - `io.inData: UInt(256.W)` - new hashed seed.
  - `io.writePool: Bool` - start write inData into pools.
  - `io.readPool: Bool` - uses an internal reseed counter to generate a mask over the 32 pools and clear used pools when reseeding.
  - `io.notEnoughDataFlag: Bool` - indicates data in the pools is not enough.
  - `io.outPoolsCount: UInt(5.W))` - number of pools included in output.
  - `io.outSeedingData: Vec(32, UInt(256.W))` - masked pool data.
  - `io.outUpdateData: UInt(32.W)` - current pool’s data.

### ChaCha

- IO (file: `Agile-HW-Design-RNG/src/main/scala/ChaCha.scala`)
  - `io.in_start: Bool` - start pulse, telling core to capture `in_key`, `in_nonce`, and `in_counter` and begin computing.
  - `io.in_key: UInst(256.W)` - 256‑bit ChaCha key.
  - `io.in_nonce: UInt(64.W)` - 64‑bit nonce.
  - `io.in_counter: UInt(64.W)` - 64‑bit block counter.
  - `io.out_Decoding_key: UInt(521.W))` - The 512‑bit ChaCha keystream block
  - `io.out_ready: Bool` - Done or valid flag

### Salsa20

- IO (file: `Agile-HW-Design-RNG/src/main/scala/Salsa20.scala`)
  - Same interface as `ChaCha` (`in_start/in_key/in_nonce/in_counter/out_Decoding_key/out_ready`)

### top_fsm

- IO (file: `Agile-HW-Design-RNG/src/main/scala/Salsa20.scala`)
  - `io.in_start: Bool` - start pulse
  - `io.in_random_data: UInt(3.W)` - entropy input data (tied to button)
  - `io.out_led: UInt(8.W)` - output random number (conntected to leds)
  - `io.out_read: Bool` - ready /valid flag.

## Testing

* **AES256Test** `(src/test/scala/AES256Test.scala)`
  AES‑256 encryption of **"abc"** against a known expected ciphertext.
* **SHA256Tester** `(src/test/scala/SHA256Tester.scala)`
  hashes a single padded **"abc"** block and checks against the standard SHA‑256 known answer.
* **SHAd256Tester** `(src/test/scala/SHAd256Tester.scala)`
  hashes padded **"abc"** and compares against the known double‑SHA‑256 digest.
* **PoolsTester** `(src/test/scala/PoolsTester.scala)`
  sanity test for pool writes, reseed behavior, and **outPoolsCount** for different reseed counter values.
* **CoSimulationTest** `(src/test/scala/CoSimulationTest.scala)`
  co‑simulation against Java built-in library for AES256 and SHA256:
  * AES‑256 core vs **Java Chiper AES256** for multiple plaintexts.
  * SHA‑256 and SHAd256 cores vs Java **MessageDigest("SHA-256")** (single and double hash).
    Includes helper traits and classes (AES256Hardware, AES256GoldenModel, SHA256Hardware, SHA256GoldenModel, SHAd256Hardware, SHAd256GoldenModel, SHA256Helper).
* **test_ChaCha** `(src/test/scala/test_ChaCha.scala)`
  runs the **ChaCha** core on selected test vectors and checks the 512‑bit **out_Decoding_key** against known reference outputs.
* **test_Salsa20** `(src/test/scala/test_Salsa20.scala)`
  similarly validates the **Salsa20** core keystream against known vectors.

## Support Code

* **Emit** `(src/main/scala/Emit.scala)` - SBT entry points to emit SystemVerilog:
  * **AES256Emit**: Emmitting SystemVerilog for AES256 module
  * **SHAd256Emit**: Emmitting SystemVerilog for SHA256 module
  * **SHA256Emit**: Emmitting SystemVerilog for SHAd256 module
  * **PoolsEmit**:  Emmitting SystemVerilog for Pools module
  * **ChaChaEmit**:  Emmitting SystemVerilog for ChaCha module
  * **Salsa20Emit**:  Emmitting SystemVerilog for Salsa20 module

## Build & Test

- Requirements: JDK 17+, `sbt`, Scala 2.13, Chisel 6.7.0, and chiseltest 6.0.0.
- Run all tests: `sbt test`
- Run a specific test: `sbt "testOnly *SHA256Tester"`, `sbt "testOnly *SHAd256Tester"`, or `sbt "testOnly *AES256Test"`.

## SystemVerilog Generation

- Run from `Agile-HW-Design-RNG` directory with sbt:
  - `sbt "runMain AES256Emit"` → emits SV for AES256 into `generated/`.
  - `sbt "runMain SHA256Emit"` → emits SV for SHA256 into `generated/`.
  - `sbt "runMain SHAd256Emit"` → emits SV for SHAd256 into `generated/`.
  - `sbt "runMain PoolsEmit"` → emits SV for Pools into `generated/`.
  - `sbt "runMain ChaChaEmit"` → emits SV for ChaCha into `generated/`.
  - `sbt "runMain Salsa20Emit"` → emits SV for Salsa20 into `generated/`.
